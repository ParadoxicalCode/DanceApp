Ход выполнения программы:
1) При необходимости пользователь заносит в базу данных судей, возрастные категории и клубы.
2) Пользователь создаёт или выбирает соревнование из имеющихся и переходит на форму "меню соревнования"
3) Регистрация участников
4) Пользователь переходит на форму "группы"
5) Программа по дате рождения распределяет участников по возрастным категориям, а затем случайно распределяет участников по заходам
6) Формируется дерево заходов: соревнование => группа => заход => участники
7) Пользователь переходит на форму распределения мест
8) Пользователь выбирает долю пар переходящих в следующий тур (не более 2/3 и не менее 1/2 участвующих пар) 
Вводим два числа. Первое - числитель, второе - знаменатель.
9) Пользователь нажимает на кнопку печать. Распечатывается список заходов и категорий
10) Повторное нажатие. Распечатывается таблица, куда судьи будут вносить оценки
11) Судьи вносят оценки в бланки. Пользователь вносит оценки в матрицу.
12) Происходит распределение мест и обработка исключений (если для прохождения в следующий тур будет больше пар чем необходимо, но это если есть заходы)
13) Если остались заходы, то программа стирает все данные из таблицы. Повторять пункт 12 до тех пор, пока заходов не останется
14) Все прошедшие отбор пары суммируются и все или большая часть переходит в следующий тур


Что надо сделать в приложении:
1) Пагинацию
2) Фильтры
3) Сделать многостраничность
4) Удаление нескольких записей при выделении
6) Валидацию при нажатии на кнопку сохранить
7) Закончить алгоритм распределения мест
8) Добавить форму регламент
9) Реданс
10) Если пара не пришла на соревнование, то пользователь ставит галочку напротив пары, которая не пришла и все ячейки этой пары заполняются чёрточками
Если на соревновании до 8 пар, то тур = финал, если таково решение главного судьи
11) Когда нажимаю на кнопку, она меняет цвет
При нажатии на другую кнопку, предыдущая кнопка становится изначального цвета, а нажатая кнопка меняет цвет
12) В форме с datagrid будет: таблица, пагинация, фильтрация, поиск, боковое меню навигации, информация о количестве записей
на странице, информация об общем количестве записей
13) На четвёртой форме будет распределение мест между парами, информация о текущем заходе и танце, кнопка 
расчитать (при нажатии все данные записываются в БД) и далее. После финала выводится финальная таблица
14) Избавиться от MessageBox
15) Клубы и судьи должны регистрироваться каждый раз в новом соревновании!
16) В название окна выводить текущее соревнование
17) Когда нажимаешь на textbox, текст выделяется. Это нужно для более быстрого ввода
Добавить на форме "Places" переключение между ячейками с помощью стрелок
18) добавить классы для сущностей: Cities, Countries, Clubs, Positions, Judges, Dancers, Competitions,
ScoresInDance, Pairs, Gender, PairsInPerformance, Performances, Dances, Groups, Tours, JudgesInGroup,
JudgesInPerformance, AgeCategoriesInGroup, AgeCategories.
Из них общими для всех БД будут: Cities, Countries, Positions, Gender, Dances, Tours, AgeCategories
19) Валидации в БД не будет, только на стороне клиента. То есть null, уникально или нет



Больше 60 пар в одном соревновании быть не может





Алгоритм Skating:
1) Сформировать таблицу
2) Валидация
3) Расчёт количества мест в правой части таблицы
4) Распределение мест за танец
(Цикл, пока не проверили все столбцы)
	(Есть ли участники в текущем столбце, набравшие большинство голосов судей?)
		Записываем всех участников, набравших большинство голосов судей.
		(В текущем столбце есть только один участник, набравший большинство голосов судей?)
			Присуждаем очередное место.
			
		(Иначе есть ли в текущем столбце два участника, набравших большинство голосов судей?)
			(Есть ли участник с наибольшим количеством голосов судей?)
				(Правило 6)
				Присудить участнику с большим количеством голосов судей очередное место. 
			(Иначе)
				(Правило 7)
				(Есть ли участник с наименьшей суммой составляющих?)
					(Правило 7а)
					Присудить участнику с наименьшей суммой составляющих очередное место
				(Иначе)
					(Правило 7б)
					Для спорящих за текущее место пар сравнить сумму мест за более низкие места
					(Есть ли участник с большей суммой составляющих?)
						Присуждаем 
						(Правило 8)
						Присудить обоим участникам одинаковое место, равное результату деления суммы мест, на которые претендуют эти пары на количество претендующих пар. 
				
		(Иначе есть ли участник с наибольшим количеством голосов судей?)
			Присудить участнику с большим количеством голосов судей очередное место.
		(Иначе)
			(Есть ли участник с наибольшей суммой составляющих?)
				Присудить участнику с большим количеством голосов судей очередное место.
			(Иначе)
				Сравнить сумму составляющих и присвоить очередное место участнику с наибольшей суммой.
			и присвоить очередное место участнику с наибольшей суммой.
			
			
			

Программирование:
{Binding Path=НазваниеСвойства}
С помощью ключевого слова Path мы определяем свойство, с которым хотим связаться, однако, 
Path - это свойство по умолчанию, мы можем его опустить и получить следующую нотацию:
{Binding НазваниеСвойства}

unit тесты должны быть в отдельной сборке (dll/exe), то есть отдельный проект в том же решении

public class Rectangle {
    public int width;
    public int height;
}

Rectangle rect = new Rectangle();
rect.width = -1;
rect.height = -1;




Для работы с SQLite необходимо установить пакет NuGet Microsoft.EntityFrameworkCore.SqlServer
и пакет Microsoft.EntityFrameworkCore.Tools
В C# нужно прописывать using Microsoft.EntityFrameworkCore;

Чтобы импортировать БД в проект надо прописать в консоли пакета:
Scaffold-DbContext "Data Source=C:\\Users\\makol\\OneDrive\\Рабочий стол\\Диплом\\Приложение\\DataBase.db" Microsoft.EntityFrameworkCore.Sqlite
В проекте не должно быть ошибок, то есть он должен запускаться

Scaffold-DbContext "Data Source=C:\\Users\\makol\\Desktop\\Skating.db" Microsoft.EntityFrameworkCore.Sqlite

Scaffold-DbContext "Data Source=.\Model\Data\Skating.db" Microsoft.EntityFrameworkCore.Sqlite -OutputDir DataBase

Scaffold-DbContext "Data Source=C:\Users\makol\Desktop\Skating.db" Microsoft.EntityFrameworkCore.Sqlite -OutputDir DataBase







Свойства полей сущности:
Autoincrement стоит по умолчанию
Отключить Autoincrement: [DatabaseGenerated(DatabaseGeneratedOption.None)]
Не null: [Required]
Установить длину: [Length(200)]

Установить null:
public int? Age { get; set } // это работает, но SQLite вообще всё равно. Добавляются пустые строки в любом из исходов


Составной первичный ключ:
public class ApplicationContext : DbContext
{
    public DbSet<User> Users { get; set; }
    public ApplicationContext()
    {
        Database.EnsureDeleted();
        Database.EnsureCreated();
    }
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<User>().HasKey(u => new { u.PassportSeria, u.PassportNumber});
    }
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer(@"Server=(localdb)\mssqllocaldb;Database=efbasicsappdb;Trusted_Connection=True;");
    }
}
 
public class User
{
    public string? PassportNumber { get; set; }
    public string? PassportSeria { get; set; }
 
    public string? Name { get; set; }
}




Уникальное значение:
using Microsoft.EntityFrameworkCore;
 
public class ApplicationContext : DbContext
{
    public DbSet<User> Users { get; set; } = null!;
    public ApplicationContext()
    {
        Database.EnsureDeleted();
        Database.EnsureCreated();
    }
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlite("Data Source=helloapp.db");
    }
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<User>().HasAlternateKey(u => u.Passport);
    }
}
 
public class User
{
    public int Id { get; set; }
    public string? Name { get; set; }
    public string? Passport { get; set; }
}










После этого нужно открыть вид => другие окна => консоль диспетчер пакетов
Прописать в консоли: Add-Migration Initial
Это создаст модель базы данных как в SSMS

Ещё прописывают:
Add-Migration InitialCreate
Update-Database

Если надо обновить БД, то удаляем папку bin, все миграции и выполняем пересборку проекта. Тогда можно снова прописать эти команды


Далее создаём класс, где будет взаимодействие с БД (CRUD)
В этом классе можно прописать взаимодействие для всех сущностей. Отдельные классы для каждой сущности создавать не требуется.
using ManageStaffDBApp.Model.Data;
usimg System.Linq;

namespace ManageStaffDBApp.Model
{
	public static class Dataworker
	{
		// Добавление.
		public static string CreateDepartment(string name)
		{
			string result = "Уже существует";
			using(ApplicationContext db = new ApplicationContext())
			{
				// Проверяем существует ли отдел.
				bool checkIsExist = db.Departments.Any(el => el.Name == name);
				if (!checkIsExist)
				{
					Department newDepartment = new Department { Name = name };
					db.Departments.Add(newDepartment);
					db.SaveChanges();
					result = "Запись успешно добавлена!";
				}
				return result;
			}
		}
		
		
		public static string CreatePosition(string name, decimal salary, int maxNumber, Department department) // В конце это внешний ключ.
		{
			string result = "Уже существует";
			using(ApplicationContext db = new ApplicationContext())
			{
				// Проверяем существует ли позиция.
				bool checkIsExist = db.Positions.Any(el => el.Name == name && el.Salary == salary);
				if (!checkIsExist)
				{
					Position newPosition = new Position
					{
						Name = name;
						Salary = salary;
						MaxNumber = maxNumber;
						DepartmentId = department.Id
					};
					db.Positions.Add(newPosition);
					db.SaveChanges();
					result = "Запись успешно добавлена!";
				}
				return result;
			}
		}
	}
}

Добавление:
UserService userService = new UserService

Поиск:
public User Get(string name)
{
	using (ApplicationContext db = new ApplicationContext())
	{
		var user = db.Users.FirstOrDefault(x => x.Name == name);
		return user;
	}
}

При вызове этой функциии мы указываем параметр, по которому ищем, а
фукция возвращает контекст найденной записи
*UserService - название класса взаимодействия с БД (CRUD)

Вызов функции:
UserService userService = new UserService();
var user = userService.Get(name);
if (user != null)
{
	Console.WriteLine("Пользователь найден: " + user.Name + "\n" + user.Age);
}
else
{
	Console.WriteLine("Пользователь не найден");
}






public class Stock
{
	[PrimaryKey, AutoIncrement]
	public int Id { get; set; }
	[MaxLength(8)]
	public string Symbol { get; set; }
}

public class Valuation
{
	[PrimaryKey, AutoIncrement]
	public int Id { get; set; }
	[Indexed]
	public int StockId { get; set; }
	public DateTime Time { get; set; }
	public decimal Price { get; set; }
}



Использование SQL запросов:
public static IEnumerable<Valuation> QueryValuations (SQLiteConnection db, Stock stock)
{
	return db.Query<Valuation> ("select * from Valuation where StockId = ?", stock.Id);
}
