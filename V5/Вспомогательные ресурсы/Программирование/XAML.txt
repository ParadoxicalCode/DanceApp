Шпаргалка по XAML.

Для задания кнопки на несколько ячеек (где 0 - это точка отсчёта слева):
<Button Grid.Column="0" Grid.Row="1" Content="Объединение трех столбцов" Grid.ColumnSpan="3"  />

GridSplitter - штука, которую можно растягивать (динамически изменяющаяся ширина):
<Grid>
    <Grid.ColumnDefinitions>
        <ColumnDefinition Width="*" />
        <ColumnDefinition Width="Auto" />
        <ColumnDefinition Width="*" />
    </Grid.ColumnDefinitions>
    <Button Grid.Column="0" Content="Левая кнопка" />
    <GridSplitter Grid.Column="1" ShowsPreview="False" Width="3"
        HorizontalAlignment="Center" VerticalAlignment="Stretch" />
    <Button Grid.Column="2" Content="Правая кнопка" />
</Grid>

<ColumnDefinition Width="Auto" /> - это ширина границы.

То же самое, только распространяется на несколько строк:
<Grid>
	<Grid.ColumnDefinitions>
		<ColumnDefinition Width="*" />
		<ColumnDefinition Width="Auto" />
		<ColumnDefinition Width="*" />
	</Grid.ColumnDefinitions>
	<Grid.RowDefinitions>
		<RowDefinition></RowDefinition>
		<RowDefinition></RowDefinition>
	</Grid.RowDefinitions>
	<GridSplitter Grid.Column="1" Grid.RowSpan="2" ShowsPreview="False" Width="3"
		HorizontalAlignment="Center" VerticalAlignment="Stretch" />
</Grid>

Более продвинутый пример:
<Grid>
    <Grid.ColumnDefinitions>
        <ColumnDefinition Width="*" />
        <ColumnDefinition Width="Auto" />
        <ColumnDefinition Width="*" />
    </Grid.ColumnDefinitions>
    <Grid.RowDefinitions>
        <RowDefinition Height="*"></RowDefinition>
        <RowDefinition Height="Auto"></RowDefinition>
        <RowDefinition Height="*"></RowDefinition>
    </Grid.RowDefinitions>
    <GridSplitter Grid.Column="1"  Grid.Row="0" ShowsPreview="False" Width="3"
        HorizontalAlignment="Center" VerticalAlignment="Stretch" />
    <GridSplitter Grid.Row="1" Grid.ColumnSpan="3" Height="3"
        HorizontalAlignment="Stretch" VerticalAlignment="Center" />
    <Canvas Grid.Column="0" Grid.Row="0">
        <TextBlock>Левая панель</TextBlock>
    </Canvas>
    <Canvas Grid.Column="2" Grid.Row="0" Background="LightGreen">
        <TextBlock>Правая панель</TextBlock>
    </Canvas>
    <Canvas Grid.ColumnSpan="3" Grid.Row="2" Background="#dfffff">
        <TextBlock Canvas.Left="60">Нижняя панель</TextBlock>
    </Canvas>
</Grid>

DockPanel - прижимает свои элементы к какой-либо стороне:
<DockPanel LastChildFill="True">
	<Button DockPanel.Dock="Top" Background="AliceBlue" Content="Верхняя кнопка" />
	<Button DockPanel.Dock="Bottom" Background="BlanchedAlmond" Content="Нижняя кнопка" />
	<Button DockPanel.Dock="Left" Background="Aquamarine" Content="Левая кнопка" />
	<Button DockPanel.Dock="Right" Background="DarkGreen" Content="Правая кнопка" />
	<Button Background="LightGreen" Content="Центр" />
</DockPanel>

Если прижать два элемента к одной стороне, то они будут идти по порядку

WrapPanel - работает как StackPanel, только переносит элементы на следующую строку, если они не помещаются

WrapPanel (по горизонтали):
<WrapPanel>
	<Button Background="AliceBlue" Content="Кнопка 1" />
	<Button Background="Blue" Content="Кнопка 2" />
	<Button Background="Aquamarine" Content="Кнопка 3" Height="30"/>
	<Button Background="DarkGreen" Content="Кнопка 4" Height="20"/>
	<Button Background="LightGreen" Content="Кнопка 5"/>
	<Button Background="RosyBrown" Content="Кнопка 6" Width="80" />
	<Button Background="GhostWhite" Content="Кнопка 7" />
</WrapPanel>

WrapPanel (по вертикали):
<WrapPanel Orientation="Vertical">
    <Button Background="AliceBlue" Content="Кнопка 1" Height="50" />
    <Button Background="Blue" Content="Кнопка 2" />
    <Button Background="Aquamarine" Content="Кнопка 3" Width="60"/>
    <Button Background="DarkGreen" Content="Кнопка 4" Width="80"/>
    <Button Background="LightGreen" Content="Кнопка 5"/>
    <Button Background="RosyBrown" Content="Кнопка 6" Height="80" />
    <Button Background="GhostWhite" Content="Кнопка 7" />
    <Button Background="Bisque" Content="Кнопка 8" />
</WrapPanel>

Задание ширины элемента WrapPanel:
<WrapPanel ItemHeight="30" ItemWidth="80" Orientation="Horizontal">
    <Button Background="AliceBlue" Content="1" />
    <Button Background="Blue" Content="2" />
    <Button Background="Aquamarine" Content="3"/>
    <Button Background="DarkGreen" Content="4"/>
    <Button Background="LightGreen" Content="5"/>
    <Button Background="AliceBlue" Content="6"  />
    <Button Background="Blue" Content="7" />
</WrapPanel>

WrapPanel справа GridSplitter:
<Grid>
	<Grid.ColumnDefinitions>
		<ColumnDefinition Width="*" />
		<ColumnDefinition Width="Auto" />
		<ColumnDefinition Width="*" />
	</Grid.ColumnDefinitions>
	<GridSplitter Grid.Column="1" Width="4" HorizontalAlignment="Center" />

	<WrapPanel Grid.Column="2">
		<Grid Name="GridForText">
			<TextBlock TextWrapping="WrapWithOverflow" Text="Roses are red. asgkja lsgs akjlgh sgkjl" />
		</Grid>
	</WrapPanel>
</Grid>

Равномерное распределение элементов:
<UniformGrid Rows="1">
	<Rectangle Width="50" Height="50" Fill="Red" VerticalAlignment="Center"/>
	<Rectangle Width="50" Height="50" Fill="Blue" VerticalAlignment="Center"/>
	<Rectangle Width="50" Height="50" Fill="Green" VerticalAlignment="Center"/>
</UniformGrid>

Можно создавать свои стили. Стили размещаются в словаре ресурсов, который мы либо
создаём сами, либо используем App.xaml.
Если мы создаём словарь ресурсов сами, то необходимо прописать в App.xaml:
<Application.Resources>
	<ResourceDictionary>
		<ResourceDictionary.MergedDictionaries>
			<ResourceDictionary Source="Resources/Base/Brushes.xaml"/> // Путь словаря данных.
		</ResourceDictionary.MergedDictionaries>
	</ResourceDictionary>
</Applications.Resources>

Наследование стилей:
<Style x:Key="Style1">
  <Setter Property="Control.Background" Value="Yellow"/>
</Style>

<Style x:Key="Style2" BasedOn="{StaticResource Style1}">
  <Setter Property="Control.Foreground" Value="Blue"/>
</Style>




WindowStyle="None"
        AllowsTransparency="True" 
        WindowStartupLocation="CenterScreen"
        Height="1080" Width="1920">

    <Window.Background>
        <SolidColorBrush Opacity="0.8" Color="Black"/>
    </Window.Background>

    <Border Background="Transparent" Grid.Row="0" Panel.ZIndex="0" 
            BorderBrush="#FFAFAFAF" BorderThickness="2">
			

<StackPanel>
	<TextBox x:Name="myTextBox" Height="30" />
	<TextBlock x:Name="myTextBlock" Text="{Binding ElementName=myTextBox,Path=Text}" Height="30" />
</StackPanel>
	
свойства класса Binding:
	ElementName: имя элемента, к которому создается привязка
	IsAsync: если установлено в True, то использует асинхронный режим получения данных из объекта. По умолчанию равно False
	Mode: режим привязки
	Path: ссылка на свойство объекта, к которому идет привязка
	TargetNullValue: устанавливает значение по умолчанию, если привязанное свойство источника привязки имеет значение null
	RelativeSource: создает привязку относительно текущего объекта
	Source: указывает на объект-источник, если он не является элементом управления.
	XPath: используется вместо свойства path для указания пути к xml-данным

Режимы привязки:
Свойство Mode объекта Binding, которое представляет режим привязки, может принимать следующие значения:
	OneWay: свойство объекта-приемника изменяется после модификации свойства объекта-источника.
	OneTime: свойство объекта-приемника устанавливается по свойству объекта-источника только один раз. В дальнейшем изменения в источнике никак не влияют на объект-приемник.
	TwoWay: оба объекта - применки и источник могут изменять привязанные свойства друг друга.
	OneWayToSource: объект-приемник, в котором объявлена привязка, меняет объект-источник.
	Default: по умолчанию (если меняется свойство TextBox.Text, то имеет значение TwoWay, в остальных случаях OneWay).

Применение режима привязки:
<StackPanel>
    <TextBox x:Name="textBox1" Height="30" />
    <TextBox x:Name="textBox2" Height="30" Text="{Binding ElementName=textBox1, Path=Text, Mode=TwoWay}" />
</StackPanel>

Обновление привязки. UpdateSourceTrigger
Односторонняя привязка от источника к приемнику практически мгновенно изменяет свойство приемника. 
Но если мы используем двустороннюю привязку в случае с текстовыми полями (как в примере выше), 
то при изменении приемника свойство источника не изменяется мгновенно. Так, в примере выше, 
чтобы текстовое поле-источник изменилось, нам надо перевести фокус с текстового поля-приемника. 
И в данном случае в дело вступает свойство UpdateSourceTrigger класса Binding, которое задает, 
как будет присходить обновление. Это свойство в качестве принимает одно из значений перечисления UpdateSourceTrigger:
	PropertyChanged: источник привязки обновляется сразу после обновления свойства в приемнике
	LostFocus: источник привязки обновляется только после потери фокуса приемником
	Explicit: источник не обновляется до тех пор, пока не будет вызван метод BindingExpression.UpdateSource()
	Default: значение по умолчанию. Для большинства свойств это значение PropertyChanged. А для свойства Text элемента TextBox это значение LostFocus
	
Привязка к элементам, не являющимся частью вёрстки:
C#:
class Phone
{
	public string Title { get; set; }
	public string Company { get; set; }
	public int Price { get; set; }
}

XAML:
<Window.Resources>
	<local:Phone x:Key="nexusPhone" Title="Nexus X5" Company="Google" Price="25000" />
</Window.Resources>

<TextBlock x:Name="titleTextBlock" Text="{Binding Source={StaticResource nexusPhone}, Path=Title}"
	Foreground="White" Grid.Column="1"/>

Свойство TargetNullValue
На случай, если свойство в источнике привязки вдруг имеет значение null, то есть оно не установлено, мы можем задать некоторое значение по умолчанию. Например:
<Window.Resources>
    <local:Phone x:Key="nexusPhone" Company="Google" Price="25000" />
</Window.Resources>

<StackPanel>
    <TextBlock x:Name="titleTextBlock"
        Text="{Binding Source={StaticResource nexusPhone}, Path=Title, TargetNullValue=Текст по умолчанию}" />
</StackPanel>

Свойство RelativeSource позволяет установить привязку относительно элемента-источника, который связан какими-нибудь 
отношениями с элементом-приемником. Например, элемент-источник может быть одним из внешних контейнеров 
для элемента-приемника. Либо источником и приемником может быть один и тот же элемент.
Для установки этого свойства используется одноименный объект RelativeSource. У этого объекта есть свойство Mode, 
которое задает способ привязки. Оно принимает одно из значений перечисления RelativeSourceMode:
Self: привязка осуществляется к свойству этого же элемента. То есть элемент-источник привязки в то же время является и приемником привязки.
FindAncestor: привязка осуществляется к свойству элемента-контейнера. Это можно использовать для real time обновления.
Например, совместим источник и приемник привязке в самом элементе:
<TextBox Text="{Binding RelativeSource={RelativeSource Mode=Self}, Path=Background, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />

Привязка к свойствам контейнера:
<Grid Background="Black">
    <TextBlock Foreground="White"
        Text="{Binding RelativeSource={RelativeSource Mode=FindAncestor,AncestorType={x:Type Grid}}, Path=Background}" />
</Grid>
При использовании режима FindAncestor, то есть привязке к контейнеру, необходимо еще указывать параметр AncestorType и 
передавать ему тип контейнера в виде выражения AncestorType={x:Type Тип_элемента-контейнера}. При этом в качестве контейнера 
мы могли бы выбрать любой контейнер в дереве элементов, в частности, в данном случае кроме Grid таким контейнером также является элемент Window.


