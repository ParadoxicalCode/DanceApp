Программирование:
{Binding Path=НазваниеСвойства}
С помощью ключевого слова Path мы определяем свойство, с которым хотим связаться, однако, 
Path - это свойство по умолчанию, мы можем его опустить и получить следующую нотацию:
{Binding НазваниеСвойства}

unit тесты должны быть в отдельной сборке (dll/exe), то есть отдельный проект в том же решении

public class Rectangle {
    public int width;
    public int height;
}

Rectangle rect = new Rectangle();
rect.width = -1;
rect.height = -1;


Для работы с SQLite необходимо установить пакет NuGet Microsoft.EntityFrameworkCore.SqlServer
и пакет Microsoft.EntityFrameworkCore.Tools
В C# нужно прописывать using Microsoft.EntityFrameworkCore;

Чтобы импортировать БД в проект надо прописать в консоли пакета:
Scaffold-DbContext "Data Source=C:\\Users\\makol\\OneDrive\\Рабочий стол\\Диплом\\Приложение\\DataBase.db" Microsoft.EntityFrameworkCore.Sqlite
В проекте не должно быть ошибок, то есть он должен запускаться

Scaffold-DbContext "Data Source=C:\\Users\\makol\\Desktop\\Skating.db" Microsoft.EntityFrameworkCore.Sqlite

Scaffold-DbContext "Data Source=.\Model\Data\Skating.db" Microsoft.EntityFrameworkCore.Sqlite -OutputDir DataBase

Scaffold-DbContext "Data Source=C:\Users\makol\Desktop\Skating.db" Microsoft.EntityFrameworkCore.Sqlite -OutputDir DataBase


Свойства полей сущности:
Autoincrement стоит по умолчанию
Отключить Autoincrement: [DatabaseGenerated(DatabaseGeneratedOption.None)]
Не null: [Required]
Установить длину: [Length(200)]

Установить null:
public int? Age { get; set } // это работает, но SQLite вообще всё равно. Добавляются пустые строки в любом из исходов


Составной первичный ключ:
public class ApplicationContext : DbContext
{
    public DbSet<User> Users { get; set; }
    public ApplicationContext()
    {
        Database.EnsureDeleted();
        Database.EnsureCreated();
    }
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<User>().HasKey(u => new { u.PassportSeria, u.PassportNumber});
    }
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer(@"Server=(localdb)\mssqllocaldb;Database=efbasicsappdb;Trusted_Connection=True;");
    }
}
 
public class User
{
    public string? PassportNumber { get; set; }
    public string? PassportSeria { get; set; }
 
    public string? Name { get; set; }
}




Уникальное значение:
using Microsoft.EntityFrameworkCore;
 
public class ApplicationContext : DbContext
{
    public DbSet<User> Users { get; set; } = null!;
    public ApplicationContext()
    {
        Database.EnsureDeleted();
        Database.EnsureCreated();
    }
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlite("Data Source=helloapp.db");
    }
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<User>().HasAlternateKey(u => u.Passport);
    }
}
 
public class User
{
    public int Id { get; set; }
    public string? Name { get; set; }
    public string? Passport { get; set; }
}










После этого нужно открыть вид => другие окна => консоль диспетчер пакетов
Прописать в консоли: Add-Migration Initial
Это создаст модель базы данных как в SSMS

Ещё прописывают:
Update-Database

Когда вписываю команду миграции, надо удостовериться, что в каждой сущности указан [Key],
а также отсутствует Database.EnsureCreated();

Если надо обновить БД, то удаляем папку bin, все миграции и выполняем пересборку проекта. Тогда можно снова прописать эти команды


Далее создаём класс, где будет взаимодействие с БД (CRUD)
В этом классе можно прописать взаимодействие для всех сущностей. Отдельные классы для каждой сущности создавать не требуется.
using ManageStaffDBApp.Model.Data;
usimg System.Linq;

namespace ManageStaffDBApp.Model
{
	public static class Dataworker
	{
		// Добавление.
		public static string CreateDepartment(string name)
		{
			string result = "Уже существует";
			using(ApplicationContext db = new ApplicationContext())
			{
				// Проверяем существует ли отдел.
				bool checkIsExist = db.Departments.Any(el => el.Name == name);
				if (!checkIsExist)
				{
					Department newDepartment = new Department { Name = name };
					db.Departments.Add(newDepartment);
					db.SaveChanges();
					result = "Запись успешно добавлена!";
				}
				return result;
			}
		}
		
		
		public static string CreatePosition(string name, decimal salary, int maxNumber, Department department) // В конце это внешний ключ.
		{
			string result = "Уже существует";
			using(ApplicationContext db = new ApplicationContext())
			{
				// Проверяем существует ли позиция.
				bool checkIsExist = db.Positions.Any(el => el.Name == name && el.Salary == salary);
				if (!checkIsExist)
				{
					Position newPosition = new Position
					{
						Name = name;
						Salary = salary;
						MaxNumber = maxNumber;
						DepartmentId = department.Id
					};
					db.Positions.Add(newPosition);
					db.SaveChanges();
					result = "Запись успешно добавлена!";
				}
				return result;
			}
		}
	}
}

Добавление:
UserService userService = new UserService

Поиск:
public User Get(string name)
{
	using (ApplicationContext db = new ApplicationContext())
	{
		var user = db.Users.FirstOrDefault(x => x.Name == name);
		return user;
	}
}

При вызове этой функциии мы указываем параметр, по которому ищем, а
фукция возвращает контекст найденной записи
*UserService - название класса взаимодействия с БД (CRUD)

Вызов функции:
UserService userService = new UserService();
var user = userService.Get(name);
if (user != null)
{
	Console.WriteLine("Пользователь найден: " + user.Name + "\n" + user.Age);
}
else
{
	Console.WriteLine("Пользователь не найден");
}






public class Stock
{
	[PrimaryKey, AutoIncrement]
	public int Id { get; set; }
	[MaxLength(8)]
	public string Symbol { get; set; }
}

public class Valuation
{
	[PrimaryKey, AutoIncrement]
	public int Id { get; set; }
	[Indexed]
	public int StockId { get; set; }
	public DateTime Time { get; set; }
	public decimal Price { get; set; }
}



Использование SQL запросов:
public static IEnumerable<Valuation> QueryValuations (SQLiteConnection db, Stock stock)
{
	return db.Query<Valuation> ("select * from Valuation where StockId = ?", stock.Id);
}

Сделать миграцию
database-update
В свойствах проекта отладка общие указать путь 